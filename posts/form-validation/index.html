<!doctype html><html lang=en-us><head><meta name=ROBOTS content="INDEX, FOLLOW"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-2159845-11','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>How to validate form in ClojureScript using spec? - Clojure Blog</title><meta name=description content="How to use spec for form validation and return human understandable errors? Should you at all?

(this article is also a solution for clojure.spec on backend when you need to return human readable errors for invalid values)"><meta name=author content="Krzysztof WÅ‚adyka"><link rel="shortcut icon" href=/img/clojure-icon-32.png type=image/x-icon><link rel=stylesheet href=https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css integrity=sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js integrity=sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1 crossorigin=anonymous></script><script src=https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script><link rel=stylesheet href=/sass/main.min.e56b0f76143debd6df3cb44954ca9b65bf06439fee332c88f655980b7a15b5a7.css><script defer src=/js/anchors-for-headers.min.8b66a98885b47a4aa1c04b0d517fa11d173b74e0099f934fe46d3249bed00544.js></script><link href=/posts/index.xml rel=alternate type=application/rss+xml title="Clojure Blog"><script type=application/ld+json>{"@context":"https://www.schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"Blog","@id":"https://clojure.wladyka.eu/posts/form-validation/"},"datePublished":"2019-10-30T00:00:00","dateModified":"2019-10-30T00:00:00","name":"How to validate form in ClojureScript using spec?","headline":"How to validate form in ClojureScript using spec?","description":"How to use spec for form validation and return human understandable errors? Should you at all?\n(this article is also a solution for clojure.spec on backend when you need to return human readable errors for invalid values)\n","articleBody":"How to use spec for form validation and return human understandable errors? Should you at all?\n(this article is also a solution for clojure.spec on backend when you need to return human readable errors for invalid values)\nWhy use spec for form validation? Because you already use spec in system. Otherwise you will have to keep the same validations in two different definitions. For example spec and plumatic schema. You will fail keeping them equal on backend and frontend. You want to decrease complexity and keep system as simple as possible.\nYou can use the same spec definitions files (.cljc) in Clojure and ClojureScript, so on backend and frontend.\nIf you don\u0026rsquo;t use spec yet, it is worth to think about unify data validation in your system to one format in a whole system.\nPurpose of the spec  The spec library specifies the structure of data, validates or conforms it, and can generate data based on the spec. spec guide\n What does it really mean? Let me explain it short step by step using code.\nSpecifies the structure of data (s/def ::id (s/and pos-int?)) (s/def ::email (s/and string? (partial re-matches #\u0026#34;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,63}$\u0026#34;))) Validates (s/valid? ::id 1) =\u0026gt; true (s/valid? ::id 0) =\u0026gt; false Conforms (s/def ::name-or-id (s/or :name string? :id ::id)) (s/conform ::name-or-id 1) =\u0026gt; [:id 1] (s/conform ::name-or-id \u0026#34;foo\u0026#34;) =\u0026gt; [:name \u0026#34;foo\u0026#34;] (s/conform ::name-or-id 0) =\u0026gt; :clojure.spec.alpha/invalid Generate data (gen/sample (s/gen ::id)) =\u0026gt; (2 1 1 3 1 6 1 2 8 2) (gen/generate (s/gen ::id)) =\u0026gt; 86 The challenge Here is the point. These things you have to code yourself on top of the spec.\nConstraint validation Validate values which depend on other values. For example: check if date of birth is lower than date of graduation or check if password repeat is equal.\nWhile it is technically possible to do constraint validation by spec, there is no way to know field name of the input, which causes the error.\nTo show the issue I have to start from a simple validation.\n(s/def ::email (s/and string? (partial re-matches #\u0026#34;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,63}$\u0026#34;))) (s/def ::password-not-empty not-empty) (s/def ::password-length #(\u0026lt;= 6 (count %))) (s/def ::password (s/and string? ::password-not-empty ::password-length)) (s/def ::form (s/keys :req-un [::email ::password])) (s/explain-data ::form {:email \u0026#34;foo@example.com\u0026#34; :password \u0026#34;qwas\u0026#34;}) =\u0026gt; {:problems ({:path [:password], :pred (cljs.core/fn [%] (cljs.core/\u0026lt;= 6 (cljs.core/count %))), :val \u0026#34;qwas\u0026#34;, :via [:foo/form :foo/password :foo/password-length], :in [:password]}), :spec :foo/form, :value {:email \u0026#34;foo@example.com\u0026#34;, :password \u0026#34;qwas\u0026#34;}} Here you can read password input by :in. This is the only one way to know which value invalidated in a map data structure.\n(first (:in (s/explain-data ...))) =\u0026gt; :password Now the issue about constraint validation. You can\u0026rsquo;t compare password in (s/spec ::password-repeat ...), because on that level spec let you know only the value of ::password-repeat, but no other map values including ::password. This is why you have to do constraint validation on the first level of(s/def ::form-constraint ...) where you can\u0026rsquo;t read the name of the value which is invalid.\n(s/def ::password-equal? (fn [{:keys [password password-repeat]}] (= password password-repeat))) (s/def ::form-constraint (s/and (s/keys :req-un [::email ::password]) ::password-equal?)) (s/explain-data ::form-constraint {:email \u0026#34;foo@example.com\u0026#34; :password \u0026#34;qwaszx\u0026#34; :password-repeat \u0026#34;q\u0026#34;}) =\u0026gt; #:cljs.spec.alpha{:problems [{:path [], :pred (cljs.core/fn [{:keys [password password-repeat]}] (cljs.core/= password password-repeat)), :val {:email \u0026#34;foo@example.com\u0026#34;, :password \u0026#34;qwaszx\u0026#34;, :password-repeat \u0026#34;q\u0026#34;}, :via [:foo/form-constraint :foo/password-equal?], :in []}], :spec :foo/form-constraint, :value {:email \u0026#34;foo@example.com\u0026#34;, :password \u0026#34;qwaszx\u0026#34;, :password-repeat \u0026#34;q\u0026#34;}} :in is empty. Where will you display this error on the screen?\nTo make it easier for you, here is a visualsation of the issue. Application can\u0026rsquo;t determine the :password-repeat input is invalid from the data above.\n\nHuman readable errors (s/explain-data ::id 0) =\u0026gt; #:clojure.spec.alpha{:problems [{:path [], :pred clojure.core/pos-int?, :val 0, :via [:foo/id], :in []}], :spec :foo/id, :value 0} This is a simple, not nested data structure. With more complex data it is unreadable at all. It is designed to read by application, not for humans (end users).\nMake a solution It is time to code a final solution.\nValidate and return :via Return nil if validate, oterwise :via.\n(s/def ::email (s/and string? (partial re-matches #\u0026#34;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,63}$\u0026#34;))) (s/def ::password-not-empty not-empty) (s/def ::password-length #(\u0026lt;= 6 (count %))) (s/def ::password (s/and string? ::password-not-empty ::password-length)) (s/def ::form (s/keys :req-un [::email ::password]))(defn ?spec-problems \u0026#34;Return nil if pass.\u0026#34; [spec value] (-\u0026gt; (s/explain-data spec value) :cljs.spec.alpha/problems)) (defn spec-validate \u0026#34;Check value by spec. If validate return nil, otherwise return a reason: the :via value of spec problem.\u0026#34; [spec value] (-\u0026gt;\u0026gt; (?spec-problems spec value) (first) :via)) (spec-validate ::form {:email \u0026#34;foo@example.com\u0026#34; :password \u0026#34;qwaszx\u0026#34;}) =\u0026gt; nil (spec-validate ::form {:email \u0026#34;foo@example.com\u0026#34; :password \u0026#34;qwas\u0026#34;}) =\u0026gt; [:foo/form :foo/password :foo/password-length] Change :via vector to the error message You have [:foo/form :foo/password :foo/password-length]. Now change it into a message. Check if you have a message for spec definition one by one from back.\n(defn get-message [via messages] (-\u0026gt;\u0026gt; (reverse via) (some messages))) (get-message [:foo/form :foo/password :foo/password-length] {:foo/password \u0026#34;Not satisfy security rules.\u0026#34;}) =\u0026gt; \u0026#34;Not satisfy security rules.\u0026#34; (get-message [:foo/form :foo/password :foo/password-length] {:foo/password-length \u0026#34;Needs to be more, than 6 characters.\u0026#34; :foo/password \u0026#34;Not satisfy security rules.\u0026#34;}) =\u0026gt; \u0026#34;Needs to be at least 6 characters.\u0026#34; You have learnt how to return human redable error message from spec validation.\nConstraint valiadtion Use cases:\n Password repeat - you don\u0026rsquo;t want to have spec for this. You don\u0026rsquo;t use this value at all and don\u0026rsquo;t send in API. It is only needed to show an error on screen. Use fn instead for this one. (\u0026lt; brith graduation) - you probably want to use spec, because you use this data in the system.  What can you do about that?\nAdd an extra code in user interface to show an error message for graduation field\n if :in is [::graduation] or when :in is [] and :via contain ::birth\u0026lt;graduation.  This let you show the error message in right place of the user interface.\nTrick about mirroring s/def and :via (s/def ::instant inst?) (s/def ::created ::instant) (s/explain-data ::created 0) =\u0026gt; #:cljs.spec.alpha{:problems [{:path [], :pred (cljs.core/partial cljs.spec.alpha/valid? cljs.core/inst?), :val 0, :via [:foo/created], :in []}], :spec :foo/created, :value 0} :via doesn\u0026rsquo;t contain full path. You can\u0026rsquo;t set an error message for ::instant. But here is a trick.\n(s/def ::created (s/and ::instant)) (s/explain-data ::created 0) =\u0026gt; #:cljs.spec.alpha{:problems [{:path [], :pred (cljs.core/partial cljs.spec.alpha/valid? cljs.core/inst?), :val 0, :via [:foo/created :foo/instant], :in []}], :spec :form-validator-doc.spec/created, :value 0} Now :via contain full path.\nYou achieved full knowledge how to validate data using spec and return error messages for end users.\nFinal solution On the end you want to have a library to do all this things which I mentioned. Because it is something repeatable in each project in the same way.\nGood news. I did all this work for you and made a library form validation. You can use this in your project and you can learn more tricks from analysing the code.\nLet me show you live demo of form validation.\n","author":{"@type":"Person","name":"Krzysztof WÅ‚adyka","url":"https://wladyka.eu"}}</script><meta property=og:title content="How to validate form in ClojureScript using spec?"><meta property=og:description content="How to use spec for form validation and return human understandable errors? Should you at all?

(this article is also a solution for clojure.spec on backend when you need to return human readable errors for invalid values)"><meta property=og:type content=article><meta property=og:url content=https://clojure.wladyka.eu/posts/form-validation/><meta property=article:published_time content=2019-10-30T00:00:00+00:00><meta property=article:modified_time content=2019-10-30T00:00:00+00:00><meta name=twitter:card content=summary><meta name=twitter:title content="How to validate form in ClojureScript using spec?"><meta name=twitter:description content="How to use spec for form validation and return human understandable errors? Should you at all?

(this article is also a solution for clojure.spec on backend when you need to return human readable errors for invalid values)"><meta itemprop=name content="How to validate form in ClojureScript using spec?"><meta itemprop=description content="How to use spec for form validation and return human understandable errors? Should you at all?

(this article is also a solution for clojure.spec on backend when you need to return human readable errors for invalid values)"><meta itemprop=datePublished content=2019-10-30T00:00:00&#43;00:00><meta itemprop=dateModified content=2019-10-30T00:00:00&#43;00:00><meta itemprop=wordCount content=1111><meta itemprop=keywords content=clojurescript,spec,></head><body><div class=container><div class="row justify-content-md-center"><div class=col-xl-8><div class=top><div class="row justify-content-center justify-content-md-between align-items-center"><div class=col-auto><h1><a class=blog-title href=/><img class=kwladyka src="https://www.gravatar.com/avatar/ce810750d0cfb4c1de5a298921388556?s=140" alt="Krzysztof WÅ‚adyka">
<img src=/img/clojure-logo.svg alt="Clojure Blog"><div class="d-none d-md-inline">Clojure Blog</div></a></h1></div><div class="w-100 d-block d-md-none"></div><div class="col-auto d-md-none" style=padding-top:10px><a class=blog-title style=margin-top:10px href=/>Clojure Blog</a></div><div class="w-100 d-block d-md-none"></div><nav class=col-auto><a class=btn href=https://wladyka.eu title=Author>Author</a>
<a class=btn href=https://clojure.wladyka.eu/posts/>Archive</a>
<a class=btn href=/posts/index.xml title="Clojure Blog" type=application/rss+xml target=_blank>Feed</a></nav></div></div></div></div><div class="row justify-content-md-center"><div class=col-xl-8><div class=row><div class=col-12><article><h1 itemprop=headline>How to validate form in ClojureScript using spec?</h1><div class=post-meta>2019-10-30<div class=tags>tags
<a href=/tags/clojurescript/>clojurescript</a>
<a href=/tags/spec/>spec</a></div></div><aside class=toc><nav id=TableOfContents><ul><li><ul><li><a href=#why-use-spec-for-form-validation>Why use spec for form validation?</a></li><li><a href=#purpose-of-the-spec>Purpose of the spec</a><ul><li><a href=#specifies-the-structure-of-data>Specifies the structure of data</a></li><li><a href=#validates>Validates</a></li><li><a href=#conforms>Conforms</a></li><li><a href=#generate-data>Generate data</a></li></ul></li><li><a href=#the-challenge>The challenge</a><ul><li><a href=#constraint-validation>Constraint validation</a></li><li><a href=#human-readable-errors>Human readable errors</a></li></ul></li><li><a href=#make-a-solution>Make a solution</a><ul><li><a href=#validate-and-return-via>Validate and return <code>:via</code></a></li><li><a href=#change-via-vector-to-the-error-message>Change <code>:via</code> vector to the error message</a></li><li><a href=#constraint-valiadtion>Constraint valiadtion</a></li><li><a href=#trick-about-mirroring-s-def-and-via>Trick about mirroring <code>s/def</code> and <code>:via</code></a></li></ul></li><li><a href=#final-solution>Final solution</a></li></ul></li></ul></nav></aside><div><p>How to use <code>spec</code> for form validation and return human understandable errors? Should you at all?</p><p>(this article is also a solution for <code>clojure.spec</code> on backend when you need to return human readable errors for invalid values)</p><h2 id=why-use-spec-for-form-validation>Why use spec for form validation?</h2><p>Because you already use <code>spec</code> in system. Otherwise you will have to keep the same validations in two different definitions. For example <code>spec</code> and plumatic schema. You will fail keeping them equal on backend and frontend. You want to decrease complexity and keep system as simple as possible.</p><p>You can use the same <code>spec</code> definitions files (<code>.cljc</code>) in Clojure and ClojureScript, so on backend and frontend.</p><p>If you don&rsquo;t use <code>spec</code> yet, it is worth to think about unify data validation in your system to one format in a whole system.</p><h2 id=purpose-of-the-spec>Purpose of the spec</h2><blockquote><p>The spec library specifies the structure of data, validates or conforms it, and can generate data based on the spec.
<cite><a href=https://clojure.org/guides/spec>spec guide</a></cite></p></blockquote><p>What does it really mean? Let me explain it short step by step using code.</p><h3 id=specifies-the-structure-of-data>Specifies the structure of data</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#a6e22e>s/def</span> <span style=color:#e6db74>::id</span> (<span style=color:#a6e22e>s/and</span> pos-int?))
(<span style=color:#a6e22e>s/def</span> <span style=color:#e6db74>::email</span> (<span style=color:#a6e22e>s/and</span> string? (partial re-matches <span style=color:#f92672>#</span><span style=color:#e6db74>&#34;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,63}$&#34;</span>)))</code></pre></div><h3 id=validates>Validates</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#a6e22e>s/valid?</span> <span style=color:#e6db74>::id</span> <span style=color:#ae81ff>1</span>)
=&gt; true
(<span style=color:#a6e22e>s/valid?</span> <span style=color:#e6db74>::id</span> <span style=color:#ae81ff>0</span>)
=&gt; false</code></pre></div><h3 id=conforms>Conforms</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#a6e22e>s/def</span> <span style=color:#e6db74>::name-or-id</span> (<span style=color:#a6e22e>s/or</span> <span style=color:#e6db74>:name</span> string?
                          <span style=color:#e6db74>:id</span> <span style=color:#e6db74>::id</span>))
(<span style=color:#a6e22e>s/conform</span> <span style=color:#e6db74>::name-or-id</span> <span style=color:#ae81ff>1</span>)
=&gt; [<span style=color:#e6db74>:id</span> <span style=color:#ae81ff>1</span>]
(<span style=color:#a6e22e>s/conform</span> <span style=color:#e6db74>::name-or-id</span> <span style=color:#e6db74>&#34;foo&#34;</span>)
=&gt; [<span style=color:#e6db74>:name</span> <span style=color:#e6db74>&#34;foo&#34;</span>]
(<span style=color:#a6e22e>s/conform</span> <span style=color:#e6db74>::name-or-id</span> <span style=color:#ae81ff>0</span>)
=&gt; <span style=color:#e6db74>:clojure.spec.alpha/invalid</span></code></pre></div><h3 id=generate-data>Generate data</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#a6e22e>gen/sample</span> (<span style=color:#a6e22e>s/gen</span> <span style=color:#e6db74>::id</span>))
=&gt; (<span style=color:#ae81ff>2</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>6</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>8</span> <span style=color:#ae81ff>2</span>)
(<span style=color:#a6e22e>gen/generate</span> (<span style=color:#a6e22e>s/gen</span> <span style=color:#e6db74>::id</span>))
=&gt; <span style=color:#ae81ff>86</span></code></pre></div><h2 id=the-challenge>The challenge</h2><p>Here is the point. These things you have to code yourself on top of the <code>spec</code>.</p><h3 id=constraint-validation>Constraint validation</h3><p>Validate values which depend on other values. For example: check if date of birth is lower than date of graduation or check if password repeat is equal.</p><p>While it is technically possible to do constraint validation by <code>spec</code>, there is no way to know field name of the input, which causes the error.</p><p>To show the issue I have to start from a simple validation.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#a6e22e>s/def</span> <span style=color:#e6db74>::email</span> (<span style=color:#a6e22e>s/and</span> string? (partial re-matches <span style=color:#f92672>#</span><span style=color:#e6db74>&#34;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,63}$&#34;</span>)))

(<span style=color:#a6e22e>s/def</span> <span style=color:#e6db74>::password-not-empty</span> not-empty)
(<span style=color:#a6e22e>s/def</span> <span style=color:#e6db74>::password-length</span> <span style=color:#f92672>#</span>(&lt;= <span style=color:#ae81ff>6</span> (count %)))
(<span style=color:#a6e22e>s/def</span> <span style=color:#e6db74>::password</span> (<span style=color:#a6e22e>s/and</span> string? <span style=color:#e6db74>::password-not-empty</span> <span style=color:#e6db74>::password-length</span>))

(<span style=color:#a6e22e>s/def</span> <span style=color:#e6db74>::form</span> (<span style=color:#a6e22e>s/keys</span> <span style=color:#e6db74>:req-un</span> [<span style=color:#e6db74>::email</span> <span style=color:#e6db74>::password</span>]))

(<span style=color:#a6e22e>s/explain-data</span> <span style=color:#e6db74>::form</span> {<span style=color:#e6db74>:email</span> <span style=color:#e6db74>&#34;foo@example.com&#34;</span>
                        <span style=color:#e6db74>:password</span> <span style=color:#e6db74>&#34;qwas&#34;</span>})
=&gt;
{<span style=color:#e6db74>:problems</span> ({<span style=color:#e6db74>:path</span> [<span style=color:#e6db74>:password</span>],
             <span style=color:#e6db74>:pred</span> (<span style=color:#a6e22e>cljs.core/fn</span> [%] (<span style=color:#a6e22e>cljs.core/&lt;=</span> <span style=color:#ae81ff>6</span> (<span style=color:#a6e22e>cljs.core/count</span> %))),
             <span style=color:#e6db74>:val</span> <span style=color:#e6db74>&#34;qwas&#34;</span>,
             <span style=color:#e6db74>:via</span> [<span style=color:#e6db74>:foo/form</span> <span style=color:#e6db74>:foo/password</span> <span style=color:#e6db74>:foo/password-length</span>],
             <span style=color:#e6db74>:in</span> [<span style=color:#e6db74>:password</span>]}),
 <span style=color:#e6db74>:spec</span> <span style=color:#e6db74>:foo/form</span>,
 <span style=color:#e6db74>:value</span> {<span style=color:#e6db74>:email</span> <span style=color:#e6db74>&#34;foo@example.com&#34;</span>, <span style=color:#e6db74>:password</span> <span style=color:#e6db74>&#34;qwas&#34;</span>}}</code></pre></div><p>Here you can read <code>password</code> input by <code>:in</code>. This is the only one way to know which value invalidated in a map data structure.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(first (<span style=color:#e6db74>:in</span> (<span style=color:#a6e22e>s/explain-data</span> ...)))
=&gt; <span style=color:#e6db74>:password</span></code></pre></div><p>Now the issue about constraint validation. You can&rsquo;t compare password in <code>(s/spec ::password-repeat ...)</code>, because on that level <code>spec</code> let you know only the value of <code>::password-repeat</code>, but no other map values including <code>::password</code>. This is why you have to do constraint validation on the first level of<code>(s/def ::form-constraint ...)</code> where you can&rsquo;t read the name of the value which is invalid.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#a6e22e>s/def</span> <span style=color:#e6db74>::password-equal?</span> (<span style=color:#66d9ef>fn </span>[{<span style=color:#e6db74>:keys</span> [password password-repeat]}]
                           (= password password-repeat)))

(<span style=color:#a6e22e>s/def</span> <span style=color:#e6db74>::form-constraint</span> (<span style=color:#a6e22e>s/and</span> (<span style=color:#a6e22e>s/keys</span> <span style=color:#e6db74>:req-un</span> [<span style=color:#e6db74>::email</span> <span style=color:#e6db74>::password</span>])
                                <span style=color:#e6db74>::password-equal?</span>))

(<span style=color:#a6e22e>s/explain-data</span> <span style=color:#e6db74>::form-constraint</span> {<span style=color:#e6db74>:email</span> <span style=color:#e6db74>&#34;foo@example.com&#34;</span>
                                   <span style=color:#e6db74>:password</span> <span style=color:#e6db74>&#34;qwaszx&#34;</span>
                                   <span style=color:#e6db74>:password-repeat</span> <span style=color:#e6db74>&#34;q&#34;</span>})
=&gt;
<span style=color:#f92672>#</span><span style=color:#e6db74>:cljs.spec.alpha</span>{<span style=color:#e6db74>:problems</span> [{<span style=color:#e6db74>:path</span> [],
                              <span style=color:#e6db74>:pred</span> (<span style=color:#a6e22e>cljs.core/fn</span> [{<span style=color:#e6db74>:keys</span> [password password-repeat]}] (<span style=color:#a6e22e>cljs.core/=</span> password password-repeat)),
                              <span style=color:#e6db74>:val</span> {<span style=color:#e6db74>:email</span> <span style=color:#e6db74>&#34;foo@example.com&#34;</span>, <span style=color:#e6db74>:password</span> <span style=color:#e6db74>&#34;qwaszx&#34;</span>, <span style=color:#e6db74>:password-repeat</span> <span style=color:#e6db74>&#34;q&#34;</span>},
                              <span style=color:#e6db74>:via</span> [<span style=color:#e6db74>:foo/form-constraint</span> <span style=color:#e6db74>:foo/password-equal?</span>],
                              <span style=color:#e6db74>:in</span> []}],
                  <span style=color:#e6db74>:spec</span> <span style=color:#e6db74>:foo/form-constraint</span>,
                  <span style=color:#e6db74>:value</span> {<span style=color:#e6db74>:email</span> <span style=color:#e6db74>&#34;foo@example.com&#34;</span>, <span style=color:#e6db74>:password</span> <span style=color:#e6db74>&#34;qwaszx&#34;</span>, <span style=color:#e6db74>:password-repeat</span> <span style=color:#e6db74>&#34;q&#34;</span>}}</code></pre></div><p><code>:in</code> is empty. Where will you display this error on the screen?</p><p>To make it easier for you, here is a visualsation of the issue. Application can&rsquo;t determine the <code>:password-repeat</code> input is invalid from the data above.</p><p><a href=form.png><img src=form.png alt=form></a></p><h3 id=human-readable-errors>Human readable errors</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#a6e22e>s/explain-data</span> <span style=color:#e6db74>::id</span> <span style=color:#ae81ff>0</span>)
=&gt;
<span style=color:#f92672>#</span><span style=color:#e6db74>:clojure.spec.alpha</span>{<span style=color:#e6db74>:problems</span> [{<span style=color:#e6db74>:path</span> [],
                                 <span style=color:#e6db74>:pred</span> clojure.core/pos-int?,
                                 <span style=color:#e6db74>:val</span> <span style=color:#ae81ff>0</span>,
                                 <span style=color:#e6db74>:via</span> [<span style=color:#e6db74>:foo/id</span>],
                                 <span style=color:#e6db74>:in</span> []}],
                     <span style=color:#e6db74>:spec</span> <span style=color:#e6db74>:foo/id</span>,
                     <span style=color:#e6db74>:value</span> <span style=color:#ae81ff>0</span>}</code></pre></div><p>This is a simple, not nested data structure. With more complex data it is unreadable at all. It is designed to read by application, not for humans (end users).</p><h2 id=make-a-solution>Make a solution</h2><p>It is time to code a final solution.</p><h3 id=validate-and-return-via>Validate and return <code>:via</code></h3><p>Return <code>nil</code> if validate, oterwise <code>:via</code>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#a6e22e>s/def</span> <span style=color:#e6db74>::email</span> (<span style=color:#a6e22e>s/and</span> string? (partial re-matches <span style=color:#f92672>#</span><span style=color:#e6db74>&#34;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,63}$&#34;</span>)))

(<span style=color:#a6e22e>s/def</span> <span style=color:#e6db74>::password-not-empty</span> not-empty)
(<span style=color:#a6e22e>s/def</span> <span style=color:#e6db74>::password-length</span> <span style=color:#f92672>#</span>(&lt;= <span style=color:#ae81ff>6</span> (count %)))
(<span style=color:#a6e22e>s/def</span> <span style=color:#e6db74>::password</span> (<span style=color:#a6e22e>s/and</span> string? <span style=color:#e6db74>::password-not-empty</span> <span style=color:#e6db74>::password-length</span>))

(<span style=color:#a6e22e>s/def</span> <span style=color:#e6db74>::form</span> (<span style=color:#a6e22e>s/keys</span> <span style=color:#e6db74>:req-un</span> [<span style=color:#e6db74>::email</span> <span style=color:#e6db74>::password</span>]))</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>defn </span>?spec-problems
  <span style=color:#e6db74>&#34;Return nil if pass.&#34;</span>
  [spec value]
  (-&gt; (<span style=color:#a6e22e>s/explain-data</span> spec value)
      <span style=color:#e6db74>:cljs.spec.alpha/problems</span>))

(<span style=color:#66d9ef>defn </span>spec-validate
  <span style=color:#e6db74>&#34;Check value by spec.
</span><span style=color:#e6db74>  If validate return nil,
</span><span style=color:#e6db74>  otherwise return a reason: the :via value of spec problem.&#34;</span>
  [spec value]
  (<span style=color:#a6e22e>-&gt;&gt;</span> (<span style=color:#a6e22e>?spec-problems</span> spec value)
       (<span style=color:#a6e22e>first</span>)
       <span style=color:#e6db74>:via</span>))

(<span style=color:#a6e22e>spec-validate</span> <span style=color:#e6db74>::form</span> {<span style=color:#e6db74>:email</span> <span style=color:#e6db74>&#34;foo@example.com&#34;</span>
                       <span style=color:#e6db74>:password</span> <span style=color:#e6db74>&#34;qwaszx&#34;</span>})
=&gt; nil

(<span style=color:#a6e22e>spec-validate</span> <span style=color:#e6db74>::form</span> {<span style=color:#e6db74>:email</span> <span style=color:#e6db74>&#34;foo@example.com&#34;</span>
                       <span style=color:#e6db74>:password</span> <span style=color:#e6db74>&#34;qwas&#34;</span>})
=&gt; [<span style=color:#e6db74>:foo/form</span> <span style=color:#e6db74>:foo/password</span> <span style=color:#e6db74>:foo/password-length</span>]</code></pre></div><h3 id=change-via-vector-to-the-error-message>Change <code>:via</code> vector to the error message</h3><p>You have <code>[:foo/form :foo/password :foo/password-length]</code>.
Now change it into a message. Check if you have a message for <code>spec</code> definition one by one from back.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>defn </span>get-message
  [via messages]
  (<span style=color:#a6e22e>-&gt;&gt;</span> (reverse via)
       (some messages)))


(<span style=color:#a6e22e>get-message</span> [<span style=color:#e6db74>:foo/form</span> <span style=color:#e6db74>:foo/password</span> <span style=color:#e6db74>:foo/password-length</span>]
             {<span style=color:#e6db74>:foo/password</span> <span style=color:#e6db74>&#34;Not satisfy security rules.&#34;</span>})
=&gt; <span style=color:#e6db74>&#34;Not satisfy security rules.&#34;</span>

(<span style=color:#a6e22e>get-message</span> [<span style=color:#e6db74>:foo/form</span> <span style=color:#e6db74>:foo/password</span> <span style=color:#e6db74>:foo/password-length</span>] 
             {<span style=color:#e6db74>:foo/password-length</span> <span style=color:#e6db74>&#34;Needs to be more, than 6 characters.&#34;</span>
              <span style=color:#e6db74>:foo/password</span> <span style=color:#e6db74>&#34;Not satisfy security rules.&#34;</span>})
=&gt; <span style=color:#e6db74>&#34;Needs to be at least 6 characters.&#34;</span></code></pre></div><p><strong>You have learnt how to return human redable error message from <code>spec</code> validation.</strong></p><h3 id=constraint-valiadtion>Constraint valiadtion</h3><p>Use cases:</p><ol><li>Password repeat - you don&rsquo;t want to have <code>spec</code> for this. You don&rsquo;t use this value at all and don&rsquo;t send in API. It is only needed to show an error on screen. Use <code>fn</code> instead for this one.</li><li><code>(&lt; brith graduation)</code> - you probably want to use <code>spec</code>, because you use this data in the system.</li></ol><p>What can you do about that?</p><p>Add an extra code in user interface to show an error message for graduation field</p><ol><li>if <code>:in</code> is <code>[::graduation]</code></li><li>or when <code>:in</code> is <code>[]</code> and <code>:via</code> contain <code>::birth&lt;graduation</code>.</li></ol><p>This let you show the error message in right place of the user interface.</p><h3 id=trick-about-mirroring-s-def-and-via>Trick about mirroring <code>s/def</code> and <code>:via</code></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#a6e22e>s/def</span> <span style=color:#e6db74>::instant</span> inst?)
(<span style=color:#a6e22e>s/def</span> <span style=color:#e6db74>::created</span> <span style=color:#e6db74>::instant</span>)

(<span style=color:#a6e22e>s/explain-data</span> <span style=color:#e6db74>::created</span> <span style=color:#ae81ff>0</span>)
=&gt;
<span style=color:#f92672>#</span><span style=color:#e6db74>:cljs.spec.alpha</span>{<span style=color:#e6db74>:problems</span> [{<span style=color:#e6db74>:path</span> [], 
                              <span style=color:#e6db74>:pred</span> (<span style=color:#a6e22e>cljs.core/partial</span> cljs.spec.alpha/valid? cljs.core/inst?),
                              <span style=color:#e6db74>:val</span> <span style=color:#ae81ff>0</span>,
                              <span style=color:#e6db74>:via</span> [<span style=color:#e6db74>:foo/created</span>],
                              <span style=color:#e6db74>:in</span> []}],
                  <span style=color:#e6db74>:spec</span> <span style=color:#e6db74>:foo/created</span>, <span style=color:#e6db74>:value</span> <span style=color:#ae81ff>0</span>}</code></pre></div><p><code>:via</code> doesn&rsquo;t contain full path. You can&rsquo;t set an error message for <code>::instant</code>. But here is a trick.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#a6e22e>s/def</span> <span style=color:#e6db74>::created</span> (<span style=color:#a6e22e>s/and</span> <span style=color:#e6db74>::instant</span>))
(<span style=color:#a6e22e>s/explain-data</span> <span style=color:#e6db74>::created</span> <span style=color:#ae81ff>0</span>)
=&gt;
<span style=color:#f92672>#</span><span style=color:#e6db74>:cljs.spec.alpha</span>{<span style=color:#e6db74>:problems</span> [{<span style=color:#e6db74>:path</span> [], 
                              <span style=color:#e6db74>:pred</span> (<span style=color:#a6e22e>cljs.core/partial</span> cljs.spec.alpha/valid? cljs.core/inst?),
                              <span style=color:#e6db74>:val</span> <span style=color:#ae81ff>0</span>,
                              <span style=color:#e6db74>:via</span> [<span style=color:#e6db74>:foo/created</span> <span style=color:#e6db74>:foo/instant</span>],
                              <span style=color:#e6db74>:in</span> []}],
                  <span style=color:#e6db74>:spec</span> <span style=color:#e6db74>:form-validator-doc.spec/created</span>, <span style=color:#e6db74>:value</span> <span style=color:#ae81ff>0</span>}</code></pre></div><p>Now <code>:via</code> contain full path.</p><p><strong>You achieved full knowledge how to validate data using <code>spec</code> and return error messages for end users.</strong></p><h2 id=final-solution>Final solution</h2><p>On the end you want to have a library to do all this things which I mentioned. Because it is something repeatable in each project in the same way.</p><p>Good news. I did all this work for you and made a library <a href=https://github.com/kwladyka/form-validator-cljs>form validation</a>. You can use this in your project and you can learn more tricks from analysing the code.</p><p>Let me show you <a href=https://kwladyka.github.io/form-validator-cljs/>live demo of form validation</a>.</p></div></article></div></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"clojure-wladyka"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></body></html>