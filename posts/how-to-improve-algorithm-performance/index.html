<!doctype html><html lang=en-us><head><meta name=ROBOTS content="INDEX, FOLLOW"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-2159845-11','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>How to improve algorithm performance? - Clojure Blog</title><meta name=description content="I describe how to improve performance based on my real experience during chess challenge. No theory, real use case."><meta name=author content="Krzysztof Władyka"><link rel="shortcut icon" href=/img/clojure-icon-32.png type=image/x-icon><link rel=stylesheet href=https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css integrity=sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js integrity=sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1 crossorigin=anonymous></script><script src=https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script><link rel=stylesheet href=/sass/main.min.e56b0f76143debd6df3cb44954ca9b65bf06439fee332c88f655980b7a15b5a7.css><script defer src=/js/anchors-for-headers.min.8b66a98885b47a4aa1c04b0d517fa11d173b74e0099f934fe46d3249bed00544.js></script><link href=/posts/index.xml rel=alternate type=application/rss+xml title="Clojure Blog"><script type=application/ld+json>{"@context":"https://www.schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"Blog","@id":"https://clojure.wladyka.eu/posts/how-to-improve-algorithm-performance/"},"datePublished":"2015-08-24T00:00:00","dateModified":"2015-08-24T00:00:00","name":"How to improve algorithm performance?","headline":"How to improve algorithm performance?","description":"I describe how to improve performance based on my real experience during chess challenge. No theory, real use case.\n","articleBody":"I describe how to improve performance based on my real experience during chess challenge. No theory, real use case.\nThis article is connected with https://github.com/kwladyka/chess-challenge. Look at this small project, it is recommend to understand what I am talking about in this article.\nDo not worry if you don\u0026rsquo;t understand the code. It is about conclusions, not about code in every line.\nDo not use memory if you don\u0026rsquo;t have to Find heuristic methods to filter existing data instead of creating new.\nFor example, we want to check on chessboard if a piece captures any other pieces and count safe squares.\n(defn squares-capture-by-king [_ [col row]] [[(dec col) (dec row)] [col (dec row)] [(inc col) (dec row)] [(dec col) row] [(inc col) row] [(dec col) (inc row)] [col (inc row)] [(inc col) (inc row)]]) (defn squares-capture-by-knight [_ [col row]] [[(dec col) (- row 2)] [(inc col) (- row 2)] [(- col 2) (dec row)] [(+ col 2) (dec row)] [(dec col) (+ row 2)] [(inc col) (+ row 2)] [(- col 2) (inc row)] [(+ col 2) (inc row)]]) (defn squares-capture-by-bishop [[cols rows] [col row]] (apply concat (for [x (range 1 (inc (min cols rows)))] [[(- col x) (- row x)] [(+ col x) (+ row x)] [(- col x) (+ row x)] [(+ col x) (- row x)]]))) (defn squares-capture-by-rook [[cols rows] [col row]] (remove #{[col row]} (concat (map vector (range 1 (inc cols)) (repeat cols row)) (map vector (repeat rows col) (range 1 (inc rows)))))) (defn squares-capture-by-queen [[cols rows] [col row]] (concat (squares-capture-by-rook [cols rows] [col row]) (squares-capture-by-bishop [cols rows] [col row]))) (defn remove-positions-outside-board [[cols rows] squares] (filter (fn [[col row]] (and ((every-pred pos? #(\u0026lt;= % cols)) col) ((every-pred pos? #(\u0026lt;= % rows)) row))) squares)) (defn capture-squares [board-size piece] (-\u0026gt;\u0026gt; (case (val piece) :king (squares-capture-by-king board-size (key piece)) :queen (squares-capture-by-queen board-size (key piece)) :bishop (squares-capture-by-bishop board-size (key piece)) :rook (squares-capture-by-rook board-size (key piece)) :knight (squares-capture-by-knight board-size (key piece))) (remove-positions-outside-board board-size) (apply hash-set))) What are we doing here? We are getting the piece and count which squares this piece captures. After that, we can check if this piece captures others pieces and remove captured squares from safe squares on the chessboard.\nSo if we call\n(capture-squares [4 4] (first {[1 1] :rook})) we will get\n#{[4 1] [1 4] [1 3] [3 1] [2 1] [1 2]} It is intuitive and works, but it has bad performance!\nNow consider other heuristic solution of the same problem:\n(defn rook-capture-square? [[rook-col rook-row] [col row]] (or (= col rook-col) (= row rook-row))) (defn bishop-capture-square? [[^long bishop-col ^long bishop-row] [^long col ^long row]] (= (Math/abs (- col bishop-col)) (Math/abs (- row bishop-row)))) (defn queen-capture-square? [queen-square square] (or (rook-capture-square? queen-square square) (bishop-capture-square? queen-square square))) (defn king-capture-square? [[^long king-col ^long king-row] [^long col ^long row]] (and (\u0026lt;= (Math/abs (- col king-col)) 1) (\u0026lt;= (Math/abs (- row king-row)) 1))) (defn knight-capture-square? [[^long knight-col ^long knight-row] [^long col ^long row]] (let [col-dif (Math/abs (- col knight-col)) row-dif (Math/abs (- row knight-row))] (or (and (= col knight-col) (= row knight-row)) (and (= 1 col-dif) (= 2 row-dif)) (and (= 2 col-dif) (= 1 row-dif))))) (defn capture? [piece-notation square] (-\u0026gt;\u0026gt; (case (val piece-notation) :queen (queen-capture-square? (key piece-notation) square) :rook (rook-capture-square? (key piece-notation) square) :bishop (bishop-capture-square? (key piece-notation) square) :king (king-capture-square? (key piece-notation) square) :knight (knight-capture-square? (key piece-notation) square)))) (defn capture-any? [piece-notation squares] (-\u0026gt; (partial capture? piece-notation) (some squares) (true?))) (defn remove-capture-squares [piece-notation squares] (-\u0026gt; (partial capture? piece-notation) (remove squares))) Instead of counting squares captured by piece, we filter existing data with mathematical operations.\n(capture? (first {[1 1] :rook}) [1 3]) ;;=\u0026gt; true (capture-any? (first {[1 1] :rook}) \u0026#39;([2 3] [3 3] [4 2])) ;;=\u0026gt; false (remove-capture-squares (first {[1 1] :rook}) \u0026#39;([2 3] [3 3] [1 3] [4 2])) ;;=\u0026gt; ([2 3] [3 3] [4 2])(solutions [7 7] \u0026#39;(:king :king :queen :queen :bishop :bishop :knight)) takes 45 seconds with optimisation and 258 seconds without.\nAvoid reflections Reflections appear when you mix Java functions with Clojure without hints.\n(defn bishop-capture-square? [[^long bishop-col ^long bishop-row] [^long col ^long row]] (= (Math/abs (- col bishop-col)) (Math/abs (- row bishop-row)))) Without ^long reflections appear and it will cost cycles on CPU when this function is used.\nHow to check reflections in your code? Run REPL and call:\n(set! *warn-on-reflection* true) (require \u0026#39;main-namespace :reload-all) :reload-all is the key because it forces to reload all dependency. Warnings appear when functions are defined, not when they are used. You can also add :global-vars {*warn-on-reflection* true} to project.clj, but it will also show many warnings in clojure.core and another dependency makes a little mess.\nMore about reflections\n(solutions [7 7] \u0026#39;(:king :king :queen :queen :bishop :bishop :knight)) takes 45 seconds in REPL without reflections and 506 seconds with reflections.\nSometimes count the same Chessboard can be reflected and rotated. If you look at the example below for a while you can see that there are only 2 unique chessboards. Others are duplicated.\nThis problem is growing with the number of the same piece. For example, for 8x8 board with 8 queens numbers of duplicated boards is much bigger. In the end it has 92 solutions, but only 12 are unique. But it is not about ending solutions, it is about each solution which we count piece by piece to achieve the goal. Most of them does not pass to the end but algorithm counts duplicated boards.\nWhat I discovered in my algorithm is that it is better to count the same (rotated and reflected) boards instead of avoiding it. The cost of avoiding is bigger than counting it. Why? Because to check if the board is duplicated in pool or not, algorithm has to create reflected/rotated boards from existing one, so I was creating new data in memory to compare. At the end of counting I had to duplicate 12 unique solutions to get all 92 solutions. So the time was longer then counting duplicated boards.\nYou can see that especially in more complicated example like this one where number of solutions is 3063828 and there are 4 pieces types.\n(solutions [7 7] \u0026#39;(:king :king :queen :queen :bishop :bishop :knight)) But maybe I haven\u0026rsquo;t spent enough time to find solution based on filtering instead of creating new duplicated boards to compare.\nAll have costs. Even optimisation to not count the same. Just do some experiments.\nDo not count the same If you use pure function many times with the same input use memoize. Of course if you have enough memory.\nLess and clean means better It doesn\u0026rsquo;t make a direct difference in performance, but it makes your code more readable. Then you can easier see what you can improve.\nFor example\n(defn solutions [board-size pieces] (loop [sorted-pieces (sort-pieces pieces) boards (empty-boards-pool board-size)] (if (empty? sorted-pieces) boards (recur (rest sorted-pieces) (next-stages-of-boards boards (first sorted-pieces)))))) is exactly the same as\n(defn solutions [board-size pieces] (-\u0026gt; (partial next-stages-of-boards) (reduce (empty-boards-pool board-size) (sort-pieces pieces)))) But it is much easier to read that. So much easier to improve your code.\nJAR is faster then REPL Running the same code as jar file is faster than running the same in REPL. So when you are testing production performance, test it on the jar file.\n(solutions [7 7] \u0026#39;(:king :king :queen :queen :bishop :bishop :knight)) This takes on my computer as jar file 32 seconds, but in REPL 45 seconds.\nWatch how you run code Add to project.clj how much memory REPL can consume and with how much it will start.\n:jvm-opts [\u0026#34;-Xms4g\u0026#34; \u0026#34;-Xmx4g\u0026#34;] The same with jar file\njava -Xms4g -Xmx4g -jar chess-challenge.jar Useful tools  Use Java profilers tools like (VisualVM, YourKit or another). It can give you some clue about memory and CPU usage. no.dissamble to inspect bytecode if all cycles on CPU matter time is really simple, but useful function cheatsheet to find better functions ","author":{"@type":"Person","name":"Krzysztof Władyka","url":"https://wladyka.eu"}}</script><meta property=og:title content="How to improve algorithm performance?"><meta property=og:description content="I describe how to improve performance based on my real experience during chess challenge. No theory, real use case."><meta property=og:type content=article><meta property=og:url content=https://clojure.wladyka.eu/posts/how-to-improve-algorithm-performance/><meta property=article:published_time content=2015-08-24T00:00:00+00:00><meta property=article:modified_time content=2015-08-24T00:00:00+00:00><meta name=twitter:card content=summary><meta name=twitter:title content="How to improve algorithm performance?"><meta name=twitter:description content="I describe how to improve performance based on my real experience during chess challenge. No theory, real use case."><meta itemprop=name content="How to improve algorithm performance?"><meta itemprop=description content="I describe how to improve performance based on my real experience during chess challenge. No theory, real use case."><meta itemprop=datePublished content=2015-08-24T00:00:00&#43;00:00><meta itemprop=dateModified content=2015-08-24T00:00:00&#43;00:00><meta itemprop=wordCount content=1293><meta itemprop=keywords content=performance,></head><body><div class=container><div class="row justify-content-md-center"><div class=col-xl-8><div class=top><div class="row justify-content-center justify-content-md-between align-items-center"><div class=col-auto><h1><a class=blog-title href=/><img class=kwladyka src="https://www.gravatar.com/avatar/ce810750d0cfb4c1de5a298921388556?s=140" alt="Krzysztof Władyka">
<img src=/img/clojure-logo.svg alt="Clojure Blog"><div class="d-none d-md-inline">Clojure Blog</div></a></h1></div><div class="w-100 d-block d-md-none"></div><div class="col-auto d-md-none" style=padding-top:10px><a class=blog-title style=margin-top:10px href=/>Clojure Blog</a></div><div class="w-100 d-block d-md-none"></div><nav class=col-auto><a class=btn href=https://wladyka.eu title=Author>Author</a>
<a class=btn href=https://clojure.wladyka.eu/posts/>Archive</a>
<a class=btn href=/posts/index.xml title="Clojure Blog" type=application/rss+xml target=_blank>Feed</a></nav></div></div></div></div><div class="row justify-content-md-center"><div class=col-xl-8><div class=row><div class=col-12><article><h1 itemprop=headline>How to improve algorithm performance?</h1><div class=post-meta>2015-08-24<div class=tags>tags
<a href=/tags/performance/>performance</a></div></div><aside class=toc><nav id=TableOfContents><ul><li><ul><li><a href=#do-not-use-memory-if-you-don-t-have-to>Do not use memory if you don&rsquo;t have to</a></li><li><a href=#avoid-reflections>Avoid reflections</a></li><li><a href=#sometimes-count-the-same>Sometimes count the same</a></li><li><a href=#do-not-count-the-same>Do not count the same</a></li><li><a href=#less-and-clean-means-better>Less and clean means better</a></li><li><a href=#jar-is-faster-then-repl>JAR is faster then REPL</a></li><li><a href=#watch-how-you-run-code>Watch how you run code</a></li><li><a href=#useful-tools>Useful tools</a></li></ul></li></ul></nav></aside><div><p>I describe how to improve performance based on my real experience during chess challenge. No theory, real use case.</p><p>This article is connected with <a href=https://github.com/kwladyka/chess-challenge>https://github.com/kwladyka/chess-challenge</a>. Look at this small project, it is recommend to understand what I am talking about in this article.</p><p>Do not worry if you don&rsquo;t understand the code. It is about conclusions, not about code in every line.</p><h2 id=do-not-use-memory-if-you-don-t-have-to>Do not use memory if you don&rsquo;t have to</h2><p><strong>Find heuristic methods to filter existing data instead of creating new.</strong></p><p>For example, we want to check on chessboard if a piece captures any other pieces and count safe squares.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>defn </span>squares-capture-by-king [_ [col row]]
  [[(dec col) (dec row)]
   [col (dec row)]
   [(inc col) (dec row)]
   [(dec col) row]
   [(inc col) row]
   [(dec col) (inc row)]
   [col (inc row)]
   [(inc col) (inc row)]])

(<span style=color:#66d9ef>defn </span>squares-capture-by-knight [_ [col row]]
  [[(dec col) (- row <span style=color:#ae81ff>2</span>)]
   [(inc col) (- row <span style=color:#ae81ff>2</span>)]
   [(- col <span style=color:#ae81ff>2</span>) (dec row)]
   [(+ col <span style=color:#ae81ff>2</span>) (dec row)]
   [(dec col) (+ row <span style=color:#ae81ff>2</span>)]
   [(inc col) (+ row <span style=color:#ae81ff>2</span>)]
   [(- col <span style=color:#ae81ff>2</span>) (inc row)]
   [(+ col <span style=color:#ae81ff>2</span>) (inc row)]])

(<span style=color:#66d9ef>defn </span>squares-capture-by-bishop [[cols rows] [col row]]
  (apply concat
         (for [x (range <span style=color:#ae81ff>1</span> (inc (min cols rows)))]
           [[(- col x) (- row x)]
            [(+ col x) (+ row x)]
            [(- col x) (+ row x)]
            [(+ col x) (- row x)]])))

(<span style=color:#66d9ef>defn </span>squares-capture-by-rook [[cols rows] [col row]]
  (remove <span style=color:#f92672>#</span>{[col row]}
          (<span style=color:#a6e22e>concat</span>
            (map vector
                 (range <span style=color:#ae81ff>1</span> (inc cols))
                 (repeat cols row))
            (map vector
                 (repeat rows col)
                 (range <span style=color:#ae81ff>1</span> (inc rows))))))

(<span style=color:#66d9ef>defn </span>squares-capture-by-queen [[cols rows] [col row]]
  (<span style=color:#a6e22e>concat</span>
    (<span style=color:#a6e22e>squares-capture-by-rook</span> [cols rows] [col row])
    (<span style=color:#a6e22e>squares-capture-by-bishop</span> [cols rows] [col row])))

(<span style=color:#66d9ef>defn </span>remove-positions-outside-board [[cols rows] squares]
  (filter (<span style=color:#66d9ef>fn </span>[[col row]]
            (<span style=color:#a6e22e>and</span>
              ((<span style=color:#a6e22e>every-pred</span> pos? <span style=color:#f92672>#</span>(&lt;= % cols)) col)
              ((<span style=color:#a6e22e>every-pred</span> pos? <span style=color:#f92672>#</span>(&lt;= % rows)) row)))
          squares))

(<span style=color:#66d9ef>defn </span>capture-squares [board-size piece]
  (<span style=color:#a6e22e>-&gt;&gt;</span> (<span style=color:#a6e22e>case</span> (val piece)
         <span style=color:#e6db74>:king</span> (<span style=color:#a6e22e>squares-capture-by-king</span> board-size (key piece))
         <span style=color:#e6db74>:queen</span> (<span style=color:#a6e22e>squares-capture-by-queen</span> board-size (key piece))
         <span style=color:#e6db74>:bishop</span> (<span style=color:#a6e22e>squares-capture-by-bishop</span> board-size (key piece))
         <span style=color:#e6db74>:rook</span> (<span style=color:#a6e22e>squares-capture-by-rook</span> board-size (key piece))
         <span style=color:#e6db74>:knight</span> (<span style=color:#a6e22e>squares-capture-by-knight</span> board-size (key piece)))
       (<span style=color:#a6e22e>remove-positions-outside-board</span> board-size)
       (apply hash-set)))</code></pre></div><p>What are we doing here? We are getting the piece and count which squares this piece captures. After that, we can check if this piece captures others pieces and remove captured squares from safe squares on the chessboard.</p><p>So if we call</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#a6e22e>capture-squares</span> [<span style=color:#ae81ff>4</span> <span style=color:#ae81ff>4</span>] (first {[<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span>] <span style=color:#e6db74>:rook</span>}))</code></pre></div><p>we will get</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=color:#f92672>#</span>{[<span style=color:#ae81ff>4</span> <span style=color:#ae81ff>1</span>] [<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>4</span>] [<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>3</span>] [<span style=color:#ae81ff>3</span> <span style=color:#ae81ff>1</span>] [<span style=color:#ae81ff>2</span> <span style=color:#ae81ff>1</span>] [<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span>]}</code></pre></div><p>It is intuitive and works, but it has bad performance!</p><p>Now consider other heuristic solution of the same problem:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>defn </span>rook-capture-square? [[rook-col rook-row] [col row]]
  (or (= col rook-col)
      (= row rook-row)))

(<span style=color:#66d9ef>defn </span>bishop-capture-square? [[<span style=color:#f92672>^</span>long bishop-col <span style=color:#f92672>^</span>long bishop-row]
                              [<span style=color:#f92672>^</span>long col <span style=color:#f92672>^</span>long row]]
  (= (<span style=color:#a6e22e>Math/abs</span> (- col bishop-col))
     (<span style=color:#a6e22e>Math/abs</span> (- row bishop-row))))

(<span style=color:#66d9ef>defn </span>queen-capture-square? [queen-square square]
  (<span style=color:#a6e22e>or</span>
    (<span style=color:#a6e22e>rook-capture-square?</span> queen-square square)
    (<span style=color:#a6e22e>bishop-capture-square?</span> queen-square square)))

(<span style=color:#66d9ef>defn </span>king-capture-square? [[<span style=color:#f92672>^</span>long king-col <span style=color:#f92672>^</span>long king-row]
                            [<span style=color:#f92672>^</span>long col <span style=color:#f92672>^</span>long row]]
  (<span style=color:#a6e22e>and</span>
    (&lt;= (<span style=color:#a6e22e>Math/abs</span> (- col king-col)) <span style=color:#ae81ff>1</span>)
    (&lt;= (<span style=color:#a6e22e>Math/abs</span> (- row king-row)) <span style=color:#ae81ff>1</span>)))

(<span style=color:#66d9ef>defn </span>knight-capture-square? [[<span style=color:#f92672>^</span>long knight-col <span style=color:#f92672>^</span>long knight-row]
                              [<span style=color:#f92672>^</span>long col <span style=color:#f92672>^</span>long row]]
  (<span style=color:#66d9ef>let </span>[col-dif (<span style=color:#a6e22e>Math/abs</span> (- col knight-col))
        row-dif (<span style=color:#a6e22e>Math/abs</span> (- row knight-row))]
    (<span style=color:#a6e22e>or</span>
      (and (= col knight-col) (= row knight-row))
      (and (= <span style=color:#ae81ff>1</span> col-dif) (= <span style=color:#ae81ff>2</span> row-dif))
      (and (= <span style=color:#ae81ff>2</span> col-dif) (= <span style=color:#ae81ff>1</span> row-dif)))))

(<span style=color:#66d9ef>defn </span>capture? [piece-notation square]
  (<span style=color:#a6e22e>-&gt;&gt;</span> (<span style=color:#a6e22e>case</span> (val piece-notation)
         <span style=color:#e6db74>:queen</span> (<span style=color:#a6e22e>queen-capture-square?</span> (key piece-notation) square)
         <span style=color:#e6db74>:rook</span> (<span style=color:#a6e22e>rook-capture-square?</span> (key piece-notation) square)
         <span style=color:#e6db74>:bishop</span> (<span style=color:#a6e22e>bishop-capture-square?</span> (key piece-notation) square)
         <span style=color:#e6db74>:king</span> (<span style=color:#a6e22e>king-capture-square?</span> (key piece-notation) square)
         <span style=color:#e6db74>:knight</span> (<span style=color:#a6e22e>knight-capture-square?</span> (key piece-notation) square))))

(<span style=color:#66d9ef>defn </span>capture-any? [piece-notation squares]
  (-&gt; (partial capture? piece-notation)
      (some squares)
      (<span style=color:#a6e22e>true?</span>)))

(<span style=color:#66d9ef>defn </span>remove-capture-squares [piece-notation squares]
  (-&gt; (partial capture? piece-notation)
      (remove squares)))</code></pre></div><p>Instead of counting squares captured by piece, we filter existing data with mathematical operations.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#a6e22e>capture?</span> (first {[<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span>] <span style=color:#e6db74>:rook</span>}) [<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>3</span>])
<span style=color:#75715e>;;=&gt; true</span>
(<span style=color:#a6e22e>capture-any?</span> (first {[<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span>] <span style=color:#e6db74>:rook</span>}) <span style=color:#f92672>&#39;</span>([<span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span>] [<span style=color:#ae81ff>3</span> <span style=color:#ae81ff>3</span>] [<span style=color:#ae81ff>4</span> <span style=color:#ae81ff>2</span>]))
<span style=color:#75715e>;;=&gt; false</span>
(<span style=color:#a6e22e>remove-capture-squares</span> (first {[<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span>] <span style=color:#e6db74>:rook</span>}) <span style=color:#f92672>&#39;</span>([<span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span>] [<span style=color:#ae81ff>3</span> <span style=color:#ae81ff>3</span>] [<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>3</span>] [<span style=color:#ae81ff>4</span> <span style=color:#ae81ff>2</span>]))
<span style=color:#75715e>;;=&gt; ([2 3] [3 3] [4 2])</span></code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#a6e22e>solutions</span> [<span style=color:#ae81ff>7</span> <span style=color:#ae81ff>7</span>] <span style=color:#f92672>&#39;</span>(<span style=color:#e6db74>:king</span> <span style=color:#e6db74>:king</span> <span style=color:#e6db74>:queen</span> <span style=color:#e6db74>:queen</span> <span style=color:#e6db74>:bishop</span> <span style=color:#e6db74>:bishop</span> <span style=color:#e6db74>:knight</span>))</code></pre></div><p><strong>takes 45 seconds with optimisation and 258 seconds without.</strong></p><h2 id=avoid-reflections>Avoid reflections</h2><p>Reflections appear when you mix Java functions with Clojure without hints.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>defn </span>bishop-capture-square? [[<span style=color:#f92672>^</span>long bishop-col <span style=color:#f92672>^</span>long bishop-row]
                              [<span style=color:#f92672>^</span>long col <span style=color:#f92672>^</span>long row]]
  (= (<span style=color:#a6e22e>Math/abs</span> (- col bishop-col))
     (<span style=color:#a6e22e>Math/abs</span> (- row bishop-row))))</code></pre></div><p>Without <code>^long</code> reflections appear and it will cost cycles on CPU when this function is used.</p><p>How to check reflections in your code? Run REPL and call:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#a6e22e>set!</span> *warn-on-reflection* true)
(<span style=color:#a6e22e>require</span> <span style=color:#e6db74>&#39;main-namespace</span> <span style=color:#e6db74>:reload-all</span>)</code></pre></div><p><code>:reload-all</code> is the key because it forces to reload all dependency. Warnings appear when functions are defined, not when they are used. You can also add <code>:global-vars {*warn-on-reflection* true}</code> to project.clj, but it will also show many warnings in clojure.core and another dependency makes a little mess.</p><p><a href=http://clojuredocs.org/clojure.core/*warn-on-reflection*>More about reflections</a></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#a6e22e>solutions</span> [<span style=color:#ae81ff>7</span> <span style=color:#ae81ff>7</span>] <span style=color:#f92672>&#39;</span>(<span style=color:#e6db74>:king</span> <span style=color:#e6db74>:king</span> <span style=color:#e6db74>:queen</span> <span style=color:#e6db74>:queen</span> <span style=color:#e6db74>:bishop</span> <span style=color:#e6db74>:bishop</span> <span style=color:#e6db74>:knight</span>))</code></pre></div><p><strong>takes 45 seconds in REPL without reflections and 506 seconds with reflections.</strong></p><h2 id=sometimes-count-the-same>Sometimes count the same</h2><p>Chessboard can be reflected and rotated. If you look at the example below for a while you can see that there are only 2 unique chessboards. Others are duplicated.</p><p><img src=4n2r.png alt="4x4 2rooks 4knights"></p><p>This problem is growing with the number of the same piece. For example, for 8x8 board with 8 queens numbers of duplicated boards is much bigger. In the end it has 92 solutions, but only 12 are unique. But it is not about ending solutions, it is about each solution which we count piece by piece to achieve the goal. Most of them does not pass to the end but algorithm counts duplicated boards.</p><p>What I discovered in my algorithm is that it is better to count the same (rotated and reflected) boards instead of avoiding it. The cost of avoiding is bigger than counting it. Why? Because to check if the board is duplicated in pool or not, algorithm has to create reflected/rotated boards from existing one, so I was creating new data in memory to compare. At the end of counting I had to duplicate 12 unique solutions to get all 92 solutions. So the time was longer then counting duplicated boards.</p><p>You can see that especially in more complicated example like this one where number of solutions is 3063828 and there are 4 pieces types.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#a6e22e>solutions</span> [<span style=color:#ae81ff>7</span> <span style=color:#ae81ff>7</span>] <span style=color:#f92672>&#39;</span>(<span style=color:#e6db74>:king</span> <span style=color:#e6db74>:king</span> <span style=color:#e6db74>:queen</span> <span style=color:#e6db74>:queen</span> <span style=color:#e6db74>:bishop</span> <span style=color:#e6db74>:bishop</span> <span style=color:#e6db74>:knight</span>))</code></pre></div><p>But maybe I haven&rsquo;t spent enough time to find solution based on filtering instead of creating new duplicated boards to compare.</p><p><strong>All have costs. Even optimisation to not count the same. Just do some experiments.</strong></p><h2 id=do-not-count-the-same>Do not count the same</h2><p>If you use <a href=https://en.wikipedia.org/wiki/Pure_function>pure function</a> many times with the same input use <a href=http://clojuredocs.org/clojure.core/memoize>memoize</a>. Of course if you have enough memory.</p><h2 id=less-and-clean-means-better>Less and clean means better</h2><p>It doesn&rsquo;t make a direct difference in performance, but it makes your code more readable. Then you can easier see what you can improve.</p><p>For example</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>defn </span>solutions [board-size pieces]
  (<span style=color:#66d9ef>loop </span>[sorted-pieces (<span style=color:#a6e22e>sort-pieces</span> pieces) boards (<span style=color:#a6e22e>empty-boards-pool</span> board-size)]
    (<span style=color:#66d9ef>if </span>(<span style=color:#a6e22e>empty?</span> sorted-pieces)
      boards
      (<span style=color:#a6e22e>recur</span> (rest sorted-pieces) (<span style=color:#a6e22e>next-stages-of-boards</span> boards (first sorted-pieces))))))</code></pre></div><p>is exactly the same as</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>defn </span>solutions [board-size pieces]
  (-&gt; (partial next-stages-of-boards)
      (reduce (<span style=color:#a6e22e>empty-boards-pool</span> board-size) (<span style=color:#a6e22e>sort-pieces</span> pieces))))</code></pre></div><p>But it is much easier to read that. So much easier to improve your code.</p><h2 id=jar-is-faster-then-repl>JAR is faster then REPL</h2><p>Running the same code as jar file is faster than running the same in REPL. So when you are testing production performance, test it on the jar file.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#a6e22e>solutions</span> [<span style=color:#ae81ff>7</span> <span style=color:#ae81ff>7</span>] <span style=color:#f92672>&#39;</span>(<span style=color:#e6db74>:king</span> <span style=color:#e6db74>:king</span> <span style=color:#e6db74>:queen</span> <span style=color:#e6db74>:queen</span> <span style=color:#e6db74>:bishop</span> <span style=color:#e6db74>:bishop</span> <span style=color:#e6db74>:knight</span>))</code></pre></div><p>This takes on my computer as jar file 32 seconds, but in REPL 45 seconds.</p><h2 id=watch-how-you-run-code>Watch how you run code</h2><p>Add to project.clj how much memory REPL can consume and with how much it will start.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=color:#e6db74>:jvm-opts</span> [<span style=color:#e6db74>&#34;-Xms4g&#34;</span> <span style=color:#e6db74>&#34;-Xmx4g&#34;</span>]</code></pre></div><p>The same with jar file</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>java -Xms4g -Xmx4g -jar chess-challenge.jar</code></pre></div><h2 id=useful-tools>Useful tools</h2><ul><li>Use Java profilers tools like (VisualVM, YourKit or another). It can give you some clue about memory and CPU usage.</li><li><a href=https://github.com/gtrak/no.disassemble>no.dissamble</a> to inspect bytecode if all cycles on CPU matter</li><li><a href=http://clojuredocs.org/clojure.core/time>time</a> is really simple, but useful function</li><li><a href=http://clojure.org/cheatsheet>cheatsheet</a> to find better functions</li></ul></div></article></div></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"clojure-wladyka"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></body></html>