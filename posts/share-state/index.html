<!doctype html><html lang=en-us><head><meta name=ROBOTS content="INDEX, FOLLOW"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-2159845-11','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Share state - when to use vars, atoms, agents and refs? - Clojure Blog</title><meta name=description content="Use cases and flowchart helping decide when to use vars, atoms, agents and refs."><meta name=author content="Krzysztof Władyka"><link rel="shortcut icon" href=/img/clojure-icon-32.png type=image/x-icon><link rel=stylesheet href=https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css integrity=sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js integrity=sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1 crossorigin=anonymous></script><script src=https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script><link rel=stylesheet href=/sass/main.min.e56b0f76143debd6df3cb44954ca9b65bf06439fee332c88f655980b7a15b5a7.css><script defer src=/js/anchors-for-headers.min.8b66a98885b47a4aa1c04b0d517fa11d173b74e0099f934fe46d3249bed00544.js></script><link href=/posts/index.xml rel=alternate type=application/rss+xml title="Clojure Blog"><script type=application/ld+json>{"@context":"https://www.schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"Blog","@id":"https://clojure.wladyka.eu/posts/share-state/"},"datePublished":"2016-04-06T00:00:00","dateModified":"2016-04-06T00:00:00","name":"Share state - when to use vars, atoms, agents and refs?","headline":"Share state - when to use vars, atoms, agents and refs?","description":"Use cases and flowchart helping decide when to use vars, atoms, agents and refs.\n","articleBody":"Use cases and flowchart helping decide when to use vars, atoms, agents and refs.\nVars Vars are global for every threads.\nThey are the most common references which we use every day.\n(def x 1) When we do (def foo \u0026quot;bar\u0026quot;) all threads will share foo. It is not a problem because Clojure use immutable data structures.\n(go (def foo :bar)) (Thread/sleep 1000) foo =\u0026gt; :bar Do not change vars after creating. It is technically possible, but it is a bad idea for many reasons.\nread more about Vars\nAtoms Share access to mutable state for every thread. Change occurs synchronously. Retry when other thread changes the state during run.\nAtoms use compare-and-set model. It means that when more than one thread is trying to swap! the atom, they will have conflict and loop the function as long as compare-and-set passes.\nSo what (swap! foo-atom inc) really does? 1. Read value from a foo-atom as an old-value. 2. Do on this value inc function as a new-value. 3. Save the new-value only if foo-atom is still the old-value. If not, loop to the point 1! Unlimited times, as long as while saving the new-value atom will still have still old-value!\n(def counter (atom 0)) (def foo (atom 1)) (defn slow-inc [n] (swap! counter inc) (Thread/sleep 200) (inc n)) (pmap (fn [_] (swap! foo slow-inc)) (range 100)) @counter @foo =\u0026gt; 1602 =\u0026gt; 101 What happens here? pmap works parallel, so all threads at \u0026ldquo;the same time\u0026rdquo; are doing swap! foo. Each time when do slow-inc, also increase the counter with very fast inc. So probability of conflict during swap! counter is very low, but still rules are the same. But during slow-inc probability of conflict while saving a new-value is very high.\n The fastest swap! does inc on the foo atom from 1 to 2. Others did the same operation and tried to save a new value. While saving the new value 2, compare an old value, excepting the value 1 (read the value at the beginning), however receive value 2 (other thread changed the atom). So all threads retry, read actual value 2 and inc them to 3. The fastest swap! inc the atom from 2 to 3. \u0026hellip;  Do not use not idempotent functions and functions with long time execution\nread more about Atoms\nAgents Share access to mutable state for every thread. Change occurs asynchronously.\nWork similar to atom, but instead of retry every time when compare-and-set! don\u0026rsquo;t pass wait in the queue in the order they were sent, so conflict will never happen. Functions never retry, but when you send function you never know when it will be run. The function will be waiting in the queue.\n(def foo-agent (agent 1)) (defn slow-inc [n] (swap! counter inc) (Thread/sleep 2000) (inc n)) (do (send foo-agent slow-inc) (send foo-agent slow-inc) (println @foo-agent) (Thread/sleep 2500) (println @foo-agent) (Thread/sleep 2500) (println @foo-agent)) 1 2 3  First, send run and do slow-inc. Second send wait in the queue. It was sent to the agent and program doesn\u0026rsquo;t care about that any more. Run next lines. Print value 1, because first send hasn\u0026rsquo;t finished yet. Wait and print value 2, because first send finished. Second send started counting just after first one, but didn\u0026rsquo;t finish yet. Wait and print 3, because second send finished.  read more about Agents\nRefs Refs works similar to database transactions. Write and read are protect in dosync. You can operate on many refs safe in transaction.\n(def foo (ref 0)) (def bar (ref 0)) (go (dotimes [_ 10] (dosync (alter foo inc) (Thread/sleep 1000) (alter bar inc) (println \u0026#34;updated, foo:\u0026#34; @foo \u0026#34;bar:\u0026#34; @bar)))) (go (dotimes [_ 10] (dosync (println \u0026#34;read, foo:\u0026#34; @foo \u0026#34;bar:\u0026#34; @bar)) (Thread/sleep 1000))) read, foo: 0 bar: 0 updated, foo: 1 bar: 1 read, foo: 1 bar: 1 updated, foo: 2 bar: 2 read, foo: 2 bar: 2 updated, foo: 3 bar: 3 read, foo: 3 bar: 3 updated, foo: 4 bar: 4 read, foo: 4 bar: 4 updated, foo: 5 bar: 5 read, foo: 5 bar: 5 updated, foo: 6 bar: 6 read, foo: 6 bar: 6 updated, foo: 7 bar: 7 read, foo: 7 bar: 7 updated, foo: 8 bar: 8 read, foo: 8 bar: 8 updated, foo: 9 bar: 9 read, foo: 8 bar: 8 updated, foo: 10 bar: 10 As we can see ,we can change many refs in one transaction and commit this changes like in database after whole dosync.\nread more about Refs\nThe choice flowchart So at least, when to use which one?\n\n Idempotent operation is the one that has no additional effect if it is called more than once with the same input parameters.\nCoordinated access is used when two Identities need to be changed together, the classic example is moving money from one bank account to another, it needs to either move completely or not at all.\nUncoordinated access is used when only one Identity needs to update, this is a very common case.\nSynchronous access is where the call expects to wait until all the identities are settled before continuing.\nAsynchronous access is \u0026ldquo;fire and forget\u0026rdquo; and let the Identity reach its new state in its own time.\n","image":"https://clojure.wladyka.eu/posts/share-state/flowchart-share-state.png","thumbnailUrl":"https://clojure.wladyka.eu/posts/share-state/flowchart-share-state.png","author":{"@type":"Person","name":"Krzysztof Władyka","url":"https://wladyka.eu"}}</script><meta property=og:title content="Share state - when to use vars, atoms, agents and refs?"><meta property=og:description content="Use cases and flowchart helping decide when to use vars, atoms, agents and refs."><meta property=og:type content=article><meta property=og:url content=https://clojure.wladyka.eu/posts/share-state/><meta property=article:published_time content=2016-04-06T00:00:00+00:00><meta property=article:modified_time content=2016-04-06T00:00:00+00:00><meta name=twitter:card content=summary_large_image><meta name=twitter:image content=https://clojure.wladyka.eu/posts/share-state/flowchart-share-state.png><meta name=twitter:title content="Share state - when to use vars, atoms, agents and refs?"><meta name=twitter:description content="Use cases and flowchart helping decide when to use vars, atoms, agents and refs."><meta itemprop=name content="Share state - when to use vars, atoms, agents and refs?"><meta itemprop=description content="Use cases and flowchart helping decide when to use vars, atoms, agents and refs."><meta itemprop=datePublished content=2016-04-06T00:00:00&#43;00:00><meta itemprop=dateModified content=2016-04-06T00:00:00&#43;00:00><meta itemprop=wordCount content=863><meta itemprop=keywords content=atom,agent,ref,></head><body><div class=container><div class="row justify-content-md-center"><div class=col-xl-8><div class=top><div class="row justify-content-center justify-content-md-between align-items-center"><div class=col-auto><h1><a class=blog-title href=/><img class=kwladyka src="https://www.gravatar.com/avatar/ce810750d0cfb4c1de5a298921388556?s=140" alt="Krzysztof Władyka">
<img src=/img/clojure-logo.svg alt="Clojure Blog"><div class="d-none d-md-inline">Clojure Blog</div></a></h1></div><div class="w-100 d-block d-md-none"></div><div class="col-auto d-md-none" style=padding-top:10px><a class=blog-title style=margin-top:10px href=/>Clojure Blog</a></div><div class="w-100 d-block d-md-none"></div><nav class=col-auto><a class=btn href=https://wladyka.eu title=Author>Author</a>
<a class=btn href=https://clojure.wladyka.eu/posts/>Archive</a>
<a class=btn href=/posts/index.xml title="Clojure Blog" type=application/rss+xml target=_blank>Feed</a></nav></div></div></div></div><div class="row justify-content-md-center"><div class=col-xl-8><div class=row><div class=col-12><article><h1 itemprop=headline>Share state - when to use vars, atoms, agents and refs?</h1><div class=post-meta>2016-04-06<div class=tags>tags
<a href=/tags/atom/>atom</a>
<a href=/tags/agent/>agent</a>
<a href=/tags/ref/>ref</a></div></div><aside class=toc><nav id=TableOfContents><ul><li><ul><li><a href=#vars>Vars</a></li><li><a href=#atoms>Atoms</a></li><li><a href=#agents>Agents</a></li><li><a href=#refs>Refs</a></li><li><a href=#the-choice-flowchart>The choice flowchart</a></li></ul></li></ul></nav></aside><div><p>Use cases and flowchart helping decide when to use vars, atoms, agents and refs.</p><h2 id=vars>Vars</h2><p><strong>Vars are global for every threads.</strong></p><p>They are the most common references which we use every day.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>def </span>x <span style=color:#ae81ff>1</span>)</code></pre></div><p>When we do <code>(def foo &quot;bar&quot;)</code> all threads will share <code>foo</code>. It is not a problem because Clojure use immutable data structures.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#a6e22e>go</span>
  (<span style=color:#66d9ef>def </span>foo <span style=color:#e6db74>:bar</span>))
(<span style=color:#a6e22e>Thread/sleep</span> <span style=color:#ae81ff>1000</span>)
foo

=&gt; <span style=color:#e6db74>:bar</span></code></pre></div><p><strong>Do not change vars after creating. It is technically possible, but it is a bad idea for many reasons.</strong></p><p><a href=http://clojure.org/reference/vars>read more about Vars</a></p><h2 id=atoms>Atoms</h2><p><strong>Share access to mutable state for every thread. Change occurs synchronously. Retry when other thread changes the state during run.</strong></p><p>Atoms use compare-and-set model. It means that when more than one thread is trying to <code>swap!</code> the atom, they will have conflict and loop the function as long as compare-and-set passes.</p><p>So what <code>(swap! foo-atom inc)</code> really does?
1. Read value from a foo-atom as an old-value.
2. Do on this value <code>inc</code> function as a new-value.
3. Save the new-value only if foo-atom is still the old-value. If not, loop to the point 1! Unlimited times, as long as while saving the new-value atom will still have still old-value!</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>def </span>counter (<span style=color:#a6e22e>atom</span> <span style=color:#ae81ff>0</span>))
(<span style=color:#66d9ef>def </span>foo (<span style=color:#a6e22e>atom</span> <span style=color:#ae81ff>1</span>))
(<span style=color:#66d9ef>defn </span>slow-inc [n]
  (<span style=color:#a6e22e>swap!</span> counter inc)
  (<span style=color:#a6e22e>Thread/sleep</span> <span style=color:#ae81ff>200</span>)
  (inc n))

(<span style=color:#a6e22e>pmap</span>
  (<span style=color:#66d9ef>fn </span>[_]
    (<span style=color:#a6e22e>swap!</span> foo slow-inc))
  (range <span style=color:#ae81ff>100</span>))

<span style=color:#f92672>@</span>counter
<span style=color:#f92672>@</span>foo
=&gt; <span style=color:#ae81ff>1602</span>
=&gt; <span style=color:#ae81ff>101</span></code></pre></div><p>What happens here? <code>pmap</code> works parallel, so all threads at &ldquo;the same time&rdquo; are doing <code>swap!</code> foo. Each time when do <code>slow-inc</code>, also increase the <code>counter</code> with very fast <code>inc</code>. So probability of conflict during <code>swap!</code> <code>counter</code> is very low, but still rules are the same. But during <code>slow-inc</code> probability of conflict while saving a new-value is very high.</p><ol><li>The fastest swap! does <code>inc</code> on the foo atom from 1 to 2.</li><li>Others did the same operation and tried to save a new value. While saving the new value 2, compare an old value, excepting the value 1 (read the value at the beginning), however receive value 2 (other thread changed the atom). So all threads retry, read actual value 2 and inc them to 3.</li><li>The fastest swap! <code>inc</code> the atom from 2 to 3.</li><li>&hellip;</li></ol><p><strong>Do not use not idempotent functions and functions with long time execution</strong></p><p><a href=http://clojure.org/reference/atoms>read more about Atoms</a></p><h2 id=agents>Agents</h2><p><strong>Share access to mutable state for every thread. Change occurs asynchronously.</strong></p><p>Work similar to atom, but instead of retry every time when <code>compare-and-set!</code> don&rsquo;t pass wait in the queue in the order they were sent, so conflict will never happen. Functions never retry, but when you <code>send</code> function you never know when it will be run. The function will be waiting in the queue.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>def </span>foo-agent (agent <span style=color:#ae81ff>1</span>))

(<span style=color:#66d9ef>defn </span>slow-inc [n]
  (<span style=color:#a6e22e>swap!</span> counter inc)
  (<span style=color:#a6e22e>Thread/sleep</span> <span style=color:#ae81ff>2000</span>)
  (inc n))

(<span style=color:#a6e22e>do</span>
  (send foo-agent slow-inc)
  (send foo-agent slow-inc)
  (println <span style=color:#f92672>@</span>foo-agent)
  (<span style=color:#a6e22e>Thread/sleep</span> <span style=color:#ae81ff>2500</span>)
  (println <span style=color:#f92672>@</span>foo-agent)
  (<span style=color:#a6e22e>Thread/sleep</span> <span style=color:#ae81ff>2500</span>)
  (println <span style=color:#f92672>@</span>foo-agent))
  
  <span style=color:#ae81ff>1</span>
  <span style=color:#ae81ff>2</span>
  <span style=color:#ae81ff>3</span></code></pre></div><ol><li>First, <code>send</code> run and do <code>slow-inc</code>.</li><li>Second <code>send</code> wait in the queue. It was sent to the agent and program doesn&rsquo;t care about that any more. Run next lines.</li><li>Print value 1, because first <code>send</code> hasn&rsquo;t finished yet.</li><li>Wait and print value 2, because first <code>send</code> finished. Second <code>send</code> started counting just after first one, but didn&rsquo;t finish yet.</li><li>Wait and print 3, because second <code>send</code> finished.</li></ol><p><a href=http://clojure.org/reference/agents>read more about Agents</a></p><h2 id=refs>Refs</h2><p><strong>Refs works similar to database transactions. Write and read are protect in dosync. You can operate on many refs safe in transaction.</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>def </span>foo (ref <span style=color:#ae81ff>0</span>))
(<span style=color:#66d9ef>def </span>bar (ref <span style=color:#ae81ff>0</span>))

(<span style=color:#a6e22e>go</span>
  (dotimes [_ <span style=color:#ae81ff>10</span>]
    (dosync 
      (alter foo inc)
      (<span style=color:#a6e22e>Thread/sleep</span> <span style=color:#ae81ff>1000</span>)
      (alter bar inc)
      (println <span style=color:#e6db74>&#34;updated, foo:&#34;</span> <span style=color:#f92672>@</span>foo <span style=color:#e6db74>&#34;bar:&#34;</span> <span style=color:#f92672>@</span>bar))))

(<span style=color:#a6e22e>go</span>
  (dotimes [_ <span style=color:#ae81ff>10</span>]
    (<span style=color:#a6e22e>dosync</span>
      (println <span style=color:#e6db74>&#34;read, foo:&#34;</span> <span style=color:#f92672>@</span>foo <span style=color:#e6db74>&#34;bar:&#34;</span> <span style=color:#f92672>@</span>bar))
    (<span style=color:#a6e22e>Thread/sleep</span> <span style=color:#ae81ff>1000</span>)))

read, foo<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>0</span> bar<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>0</span>
updated, foo<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>1</span> bar<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>1</span>
read, foo<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>1</span> bar<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>1</span>
updated, foo<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>2</span> bar<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>2</span>
read, foo<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>2</span> bar<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>2</span>
updated, foo<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>3</span> bar<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>3</span>
read, foo<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>3</span> bar<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>3</span>
updated, foo<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>4</span> bar<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>4</span>
read, foo<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>4</span> bar<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>4</span>
updated, foo<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>5</span> bar<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>5</span>
read, foo<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>5</span> bar<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>5</span>
updated, foo<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>6</span> bar<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>6</span>
read, foo<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>6</span> bar<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>6</span>
updated, foo<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>7</span> bar<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>7</span>
read, foo<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>7</span> bar<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>7</span>
updated, foo<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>8</span> bar<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>8</span>
read, foo<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>8</span> bar<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>8</span>
updated, foo<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>9</span> bar<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>9</span>
read, foo<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>8</span> bar<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>8</span>
updated, foo<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>10</span> bar<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>10</span></code></pre></div><p>As we can see ,we can change many refs in one transaction and commit this changes like in database after whole dosync.</p><p><a href=http://clojure.org/reference/refs>read more about Refs</a></p><h2 id=the-choice-flowchart>The choice flowchart</h2><p>So at least, when to use which one?</p><p><a href=flowchart-share-state.png><img src=flowchart-share-state.png alt="flowchart concurrency"></a></p><blockquote><p><strong>Idempotent</strong> operation is the one that has no additional effect if it is called more than once with the same input parameters.</p><p><strong>Coordinated</strong> access is used when two Identities need to be changed together, the classic example is moving money from one bank account to another, it needs to either move completely or not at all.</p><p><strong>Uncoordinated</strong> access is used when only one Identity needs to update, this is a very common case.</p><p><strong>Synchronous</strong> access is where the call expects to wait until all the identities are settled before continuing.</p><p><strong>Asynchronous</strong> access is &ldquo;fire and forget&rdquo; and let the Identity reach its new state in its own time.</p></blockquote></div></article></div></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"clojure-wladyka"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></body></html>